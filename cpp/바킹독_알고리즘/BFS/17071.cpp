#include <bits/stdc++.h>
using namespace std;

const int LMT = 500'000;
const int NOT_VISITED = -1;

int N, K, step;
queue<pair<int, int>> q; // {x, t}
int dist[2][LMT + 1];

int main() {
	ios::sync_with_stdio(0);
	cin.tie(0);

	for (int i = 0; i < 2; i++) fill(dist[i], dist[i] + LMT + 1, NOT_VISITED);

	cin >> N >> K;
	q.push({N, 0});
	dist[0][N] = 0;
	// 이전 좌표 최단거리를 알려면, 시간도 알아야 함. => 큐에 좌표와 시간 모두 저장해야함
	while (!q.empty()) {
		int x, t;
		tie(x, t) = q.front();
		q.pop();

		int nt = t + 1;
		for (int nx : {2 * x, x + 1, x - 1}) {
			if (nx < 0 || nx > LMT) continue;
			if (dist[nt % 2][nx] != NOT_VISITED) continue;
			q.push({nx, nt});
			dist[nt % 2][nx] = nt;
		}
	}

	while (K <= LMT) {
		if (dist[step % 2][K] <= step) {
			cout << step;
			return 0;
		}
		K += ++step;
	}
	cout << -1;
}
/*
 * 입력
 * 수빈이 위치(N), 동생 위치(K)
 *
 * 출력
 * 수빈이가 동생을 찾는 가장 빠른 시간. 단, 동생을 못찾거나 찾는 위치가 500000을 넘는 경우 -1 출력
 *
 * 조건
 * N과 K는 0 ~ 500000이다. 수빈이는 1초 후에 x + 1, x - 1, 2 * x로 이동 가능
 * 동생은 가속 운동. K+1 => K+1+2 => K+1+2+3
 *
 * === 알고리즘 ===
 * 수빈이가 동생을 찾기 위해, 같은 좌표를 방문해야할 수도 있다.
 * 예) N=17, K=5 -> 0: (17, 5) => 1: (16, 6) => 2: (15, 8) => 3: (14, 11) => 4: (15, 15)
 * 위처럼, 15를 중복해서 방문해야 가장 빨리 동생을 찾을 수 있다.
 *
 * 그렇다면, 일단 수빈이가 동생과 만날 좌표인 x를 먼저 방문해 기다리는 게 가능하다는 의미가 된다.
 * 하지만 그냥 기다리는 것은 불가능하고, 매초 앞뒤로 이동하며 기다려야 한다.
 * 즉, 수빈이는 x에 먼저 도착해 x - 1과 x를 번갈아가며 동생을 기다려야 한다는 의미가 된다.
 * 그렇다면, 동생은 수빈이가 x - 1에 가있을 때 x에 도착하면 안되고, x로 돌아올 때 도착해야 한다.
 *
 * 따라서, t초에 수빈이가 x에 도착했다면, t + 1초에는 x - 1, t + 2초에는 x에 있으므로,
 * 짝수초에 방문한 곳은 동생이 짝수초에 도착할 경우 다시 만날 수 있고,
 * 홀수초에 방문한 곳은 동생이 홀수초에 도착할 경우 다시 만날 수 있다.
 *
 * 따라서, dist배열은 짝수초와 홀수초를 구분하여 운영해야 한다.
 *
 * 그리고, 수빈이가 먼저 도착해서 기다리는 것이 가능하므로, 수빈이가 해당 좌표들로의 최단 경로를
 * 미리 구해두는 것이 가능하다.
 * 즉, 나중에 동생이 해당 좌표에 도착하면 동생이 도착한 시간이 정답이 된다.
 */