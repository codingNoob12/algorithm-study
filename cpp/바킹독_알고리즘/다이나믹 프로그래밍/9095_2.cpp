#include <bits/stdc++.h>
using namespace std;

int tc, n;

int bt(int x) {
    if (x < 0)
        return 0;
    if (x == 0)
        return 1;

    return bt(x - 1) + bt(x - 2) + bt(x - 3);
}

int main() {
    ios::sync_with_stdio(0);
    cin.tie(0);

    cin >> tc;
    while (tc--) {
        cin >> n;
        cout << bt(n) << "\n";
    }
}
/*
* 백트래킹을 이용한 풀이
모든 경우의 수를 고려하도록 각 step에서 1을 선택한 경우, 2를 선택한 경우, 3을 선택한 경우를 고려하도록 함

배열을 놓고 i 추가하고 함수 호출하고 돌아오면 i를 제거해, 롤백하는 것을 i가 1~3동안 반복해도 된다.
! 하지만, 우리는 어떤 순서대로 숫자가 배치되었는지는 중요하지 않다.
그저 각 단계에서 선택한 수들로 n을 만들 수 있는가가 중요하다.
! 그래서, 배열은 필요가 없다. 그저 n을 만드려면 앞으로 얼만큼의 값이 필요한지 알고있으면 된다.

* 단순화하다보면, 재귀처럼 보이게 된다.

그런데, 선택하다보니 n이 만들어지지 못할 수 있다. 즉, x가 음수가 될 수 있다.
이 경우는 결과에 반영되면 안되므로 0을 리턴한다.
x가 0이면, 내가 선택한 수열의 합이 n이므로, 1을 리턴해 준다.

결과적으로, 각 단계에서 1, 2, 3을 각각 선택했을 때의 가짓수의 합이 답이 된다.
*/