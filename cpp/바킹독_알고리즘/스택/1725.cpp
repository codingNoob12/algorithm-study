#include <bits/stdc++.h>
using namespace std;

int main() {
    ios::sync_with_stdio(0);
    cin.tie(0);

    int n;
    cin >> n;
    stack<pair<int, int>> S;
    long long ans = 0;
    for (int i = 0; i < n; i++) {
        int h;
        cin >> h;
        int idx = i;
        while (!S.empty() && S.top().first >= h) {
            ans = max(ans, 1LL * S.top().first * (i - S.top().second));
            idx = S.top().second;
            S.pop();
        }
        S.push({h, idx});
    }
    while (!S.empty()) {
        ans = max(ans, 1LL * S.top().first * (n - S.top().second));
        S.pop();
    }
    cout << ans << "\n";
}
/*
 * 이 문제에서는 내부 직사각형 중 넓이가 가장 큰 직사각형의 넓이를 구하는 문제이다.
 *
 * 가장 쉬운 방법은 높이별로 최대 넓이를 구해서 최대값을 업데이트 하는 방식인데,
 * 이 방식은 2중 루프를 써야되고, 높이는 10억까지, 너비는 10만까지 가능하므로 2중 루프는 불가능하다.
 *
 * 그렇다면, 좀 더 효율적으로 접근해야한다.
 *
 * 직사각형의 넓이를 구할 때, 너비 * 높이의 꼴로 표현된다.
 * 그런데, 직사각형이 되야하므로, 높이는 작은 쪽에 맞춰질 수 밖에 없다.
 * 즉, 높이가 작은 것이 큰 것을 가리게 된다.
 * 이는, monotone stack으로 높이를 관리할 수 있다는 의미가 돤다.
 *
 * 이때, 매 위치마다 넓이를 구한다면, 2중 loop가 되고 시간복잡도는 O(N*K)가 되므로 시간초과가 발생할
 * 수 있다.
 *
 * 따라서, 스택에서 꺼낼 때, 한번에 연산을 진행하면, 시간복잡도는 O(N)이 되므로 제한 조건을 만족한다.
 *
 * 그렇다면, 너비를 쉽게 구할 수 있다면 좋을 것이다. 이를 위해 인덱스 정보를 저장하자.
 * 해당 높이는 어느 인덱스까지 직사각형을 유지하는지에 대한 인덱스 정보를 저장해 두면,
 * 현재 인덱스와 해당 인덱스의 차로 너비를 쉽게 구할 수 있을 것이다.
 *
 * 따라서, 스택의 원소는 <h, idx> 형태가 된다.
 *
 * idx는 어떻게 구할까?
 * 우리는 monotone stack으로 높이를 관리하고 있다.
 * 즉, 스택에 저장된 높이보다 작은 높이가 스택에 들어가려면, 스택에 있는 모든 원소를 제거하게 된다.
 * 그렇다면, 스택에는 해당 높이보다 작은 높이만 존재하게 될 것이다.
 *
 * 즉, pop이 되는 마지막 원소의 second값에 해당하는 인덱스까지는
 * 해당 높이로 직사각형을 만들 수 있다는 것이 보장된다는 의미다.
 *
 * 쉽게 생각하자면, 윗동을 쳐내서 직사각형을 만든다고 보면 된다.
 *
 * 이를 쉽게 구현하려면 pop을 진행하면서 idx값에 top의 second값을 갱신해나가면
 * pop이 종료되었을 때, 마지막 pop이된 원소의 second값이 idx에 저장되 있을 것이다.
 *
 * 만약, 높이가 더 큰 것이 들어와 스택에서 pop 연산이 수행되지 않았다면,
 * 현재 인덱스인 i까지가 직사각형이 보장되므로 idx에 i를 저장하면 된다.
 */