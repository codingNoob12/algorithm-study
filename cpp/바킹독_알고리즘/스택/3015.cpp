#include <bits/stdc++.h>
using namespace std;

int main() {
    ios::sync_with_stdio(0);
    cin.tie(0);

    int n;
    cin >> n;
    long long ans = 0;
    stack<pair<int, int>> S;
    while (n--) {
        int h;
        cin >> h;
        int cnt = 1;
        while (!S.empty() && S.top().first <= h) {
            ans += S.top().second;
            if (S.top().first == h) cnt += S.top().second;
            S.pop();
        }
        if (!S.empty()) ans++;
        S.push({h, cnt});
    }
    cout << ans;
}
/**
 * 이 문제는 키가 주어졌을 때, 서로 볼 수 있는 쌍의 수를 구하는 문제이다.
 * 한 사람이 볼 수 있는 모든 사람의 수를 구해서 누적합 한다면, 쉽게 구할 수 있다.
 * 이 풀이는 2중 loop가 필요하므로 O(N^2) 시간복잡도를 갖는데, N이 최대 50만이므로
 * 1초안에 연산이 불가능하다.
 *
 * 따라서, 키들을 모두 저장해봤자, 루프를 돌 때 확인도 못할 것이다. 따라서 메모리 낭비이므로
 * 배열이나 벡터에 키를 저장하지 않았다.
 *
 * 그럼 키를 저장할 때 어떤 방식으로 저장하는 것이 효율적일까?
 * 바로, 스택을 이용하는 것이다.
 *
 * 이 문제에서 현재 키가 이전 키들보다 크다면, 이전 사람들을 현재 사람이 가리게 된다.
 * 따라서, 가려지는 값들은 제거하고 현재값을 넣어주면 된다.
 *
 * 키는 LIFO구조로 관리해야 빠짐없이 관리가 되므로 스택을 이용하게 된다.
 *
 * 또한, 키가 중복된다면, 연산이 중복되기 때문에, 보다 효율적으로 관리하기 위해,
 * <키, 갯수>의 쌍으로 관리하자.
 *
 * 덧붙혀, 스택에서 제거 된다는 것은 현재 값에 의해 가려져 이후의 값들에서 볼 수 없다는 의미이므로,
 * 현재 값하고만 쌍을 맺게 된다. 따라서, ans를 top의 빈도만큼 증가시켜야 한다.
 *
 * 또한, h는 스택에서 자신과 가까우면서 자신보다 키가 큰 사람까지를 확인할 수 있다.
 * 따라서, h보다 키가 큰 사람만 남을 때 까지 스택에서 pop을 진행해야 한다.
 *
 * 그리고, 스택이 비어있지 않다면, 자신보다 키가 큰 사람이 존재하므로 그 중 가장 가까운 한 사람만
 * 볼 수 있다. 그래서, ans를 1만큼 증가시킨다.
 *
 * 이후, 스택에 <키, 갯수>를 push해야 한다.
 * 키가 중복되었다면, 스택에서 push할 때, 갯수를 1만큼 증가시켜 다시 push를 해야하고
 * 그렇지 않으면, <h, 1>을 push하면 된다.
 *
 * 즉, cnt의 기본 값은 1이고, 스택에서 pop을 진행할 때, 중복 여부를 확인해서 중복되었다면,
 * cnt를 top.second만큼 증가시켜 놓으면, h의 중복 갯수를 cnt에 저장할 수 있다.
 *
 * 이후, <h, cnt>를 push하면 중복 횟수가 정확히 기록된다.
 *
 * 추가로, h를 pop할 때도 ans를 top.second만큼 증가시키는데, 이는 키가 같아도 쌍을 맺기 때문에 성립한다.
*/