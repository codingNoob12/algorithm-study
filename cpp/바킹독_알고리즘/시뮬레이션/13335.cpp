#include <bits/stdc++.h>
using namespace std;

int n, w, L;
int weights[1000];
int bridge[100];

int main() {
	ios::sync_with_stdio(0);
	cin.tie(0);

	cin >> n >> w >> L;
	for (int i = 0; i < n; i++) cin >> weights[i];

	int i = 0, t = 0;
	while (1) {
		// shift
		for (int j = w - 1; j > 0; j--) bridge[j] = bridge[j - 1];
		bridge[0] = 0; // w가 1인 경우도 동작하려면 밖에서 0번지를 0으로 세팅해야한다.
		t++;

		// 부하 계산
		int load = 0;
		for (int j = 0; j < w; j++) load += bridge[j];

		if (i >= n && !load) break;

		// 다리에 올라갈 수 있으면 추가
		if (i >= n || weights[i] + load > L) continue;
		bridge[0] = weights[i++];
	}

	cout << t;
}
/*
 * 문제
 * 강을 가로지르는 1차선 다리가 있다.
 * 이 다리를 n개의 트럭이 건너가려고 한다.
 * 트럭의 순서는 바뀔 수 없으며, 트럭의 무게는 서로 같지 않을 수 있다.
 * 다리 위에는 단지 w대의 트럭만 동시에 올라갈 수 있다.
 *
 * 다리의 길이는 w단위길이(unit distance)이며,
 * 각 트럭들은 하나의 단위시간(unit time)에 하나의 단위 길이만큼만 이동할 수 있다고 가정한다.
 * => 트럭이 다리를 건너는데 걸리는 시간은 w가 된다.
 *
 * 동시에 다리 위에 올라가 있는 트럭의 무게의 합은 다리의 최대하중인 L보다 작거나 같아야 한다.
 * 참고로, 다리 위에 완전히 올라가지 못한 트럭의 무게는 다리 위의 트럭들의 무게의 합을 계산할 때
 * 포함하지 않는다고 가정한다.
 *
 * 입력
 * 트럭의 수(n), 다리의 길이(w), 다리의 최대 하중(L)
 * 트럭들의 무게(ai)
 *
 * 출력
 * 모든 트럭들이 다리를 건너는 최단시간
 *
 * //==아이디어==//
 * 다리에 올라가 있는 트럭들의 무게를 거리별로 저장하자
 * 그리고 1초가 지날때마다, 해당 배열의 값을 shift하고, 최대하중을 넘어선 것이 아니라면 추가해보자.
 * 이 과정을 n개 차량이 모두 지나갈 때까지 loop를 돌리면 정답을 구할 수 있다.
 *
 * 다리 위의 트럭들의 무게 -> O(w)
 * 트럭의 이동 -> O(w)
 * 트럭의 추가 -> O(1)
 *
 * 위 과정을 n에 대해 수행
 *
 * 최악의 경우
 * L = 10, 모든 ai = 10. 즉, 한번에 1개 트럭만 다리를 건널 수 있는 경우
 * 각 트럭마다 w만큼 지연이 생김
 * O(nw^2) => 10,000,000
 *
 * //==아이디어2==//
 * 수학적인 접근
 * 한 번에 다리에 올라갈 수 있는 그룹들로 분할하고, 각 그룹들이 다리를 건너는데 걸리는 시간은
 * w + group_size + 1이며, 이전 그룹이 건너자마자 다리에 올라갈 수 있으므로
 * 마지막 그룹이 아니라면 -1을 해주면 된다.
 */