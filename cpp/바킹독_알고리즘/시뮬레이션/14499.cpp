#include <bits/stdc++.h>
using namespace std;

int n, m, x, y, k;
int dice[2][4];
int board[20][20];
//1: 동, 2: 서, 3: 북, 4: 남
int dx[] = {-1, 0, 0, -1, 1};
int dy[] = {-1, 1, -1, 0, 0};

void roll(int dir) {
	int tmp[4] = {};
	int target = (dir - 1) / 2 ? 0 : 1;
	int j = dir % 2 == 1 ? 3 : 1;
	for (int i = 0; i < 4; i++, j = (j + 1) % 4) tmp[i] = dice[target][j];
	for (int i = 0; i < 4; i++) dice[target][i] = tmp[i];
	dice[1 - target][1] = dice[target][1];
	dice[1 - target][3] = dice[target][3];
}

int main() {
	ios::sync_with_stdio(0);
	cin.tie(0);

	cin >> n >> m >> x >> y >> k;
	for (int i = 0; i < n; i++) {
		for (int j = 0; j < m; j++) cin >> board[i][j];
	}
	while (k--) {
		int dir;
		cin >> dir;
		int nx = x + dx[dir], ny = y + dy[dir];
		if (nx < 0 || nx >= n || ny < 0 || ny >= m) continue;
		x = nx, y = ny;
		roll(dir);
		if (!board[x][y]) board[x][y] = dice[0][3];
		else {
			dice[0][3] = board[x][y];
			dice[1][3] = board[x][y];
			board[x][y] = 0;
		}
		cout << dice[0][1] << "\n";
	}
}
/*
 * 문제
 * 크기가 N by M인 지도가 존재한다. 지도의 오른쪽은 동쪽, 위쪽은 북쪽
 *
 * 지도의 좌표는 (r, c)로 나타내며, r은 북쪽으로부터 떨어진 칸의 개수, c는 서쪽으로 부터 떨어진 칸의 개수
 * 즉, 행: r, 열: c로 표현이 된다.
 *
 * 이 지도 위에 주사위가 하나 놓여져 있음
 * 전개도는 아래와 같다.
 *   2
 * 4 1 3
 *   5
 *   6
 *
 * 주사위는 지도 위에 윗 면이 1이고, 동쪽을 바라보는 방향이 3인 상태로 놓여져 있으며,
 * 놓여져 있는 곳의 좌표는 (x, y)이다. 즉, 위의 전개도처럼 지도의 (x, y)좌표에 놓여져 있다.
 * 가장 처음에 주사위에는 모든 면에 0이 적혀있다.
 *
 * 지도의 각 칸에는 정수가 하나씩 쓰여져 있다.
 * 주사위를 굴렸을 때, 이동한 칸에 쓰여 있는 수가 0이면, 주사위의 바닥면에 쓰여 있는 수가 칸에 복사
 * 0이 아닌 경우에는 칸에 쓰여 있는 주사위의 바닥면으로 복사되며, 칸에 쓰여 있는 수는 0이 된다.
 *
 * 주사위를 놓은 곳의 좌표와 이동시키는 명령이 주어졌을 때,
 * 주사위가 이동했을 때 마다 상단에 쓰여 있는 값을 구하는 프로그램을 작성하시오
 *
 * 주사위는 지도의 바깥으로 이동시킬 수 없다. 만약 바깥으로 이동시키려고 하는 경우에는
 * 해당 명령을 무시해야 하며, 출력도 하면 안 된다.
 *
 * 입력
 * 지도의 가로(N), 세로(M), 주사위를 놓을 곳의 좌표(x, y), 명령의 개수(K)
 * 지도에 쓰여있는 수 정보 (N by M) [10미만의 음수가 아닌 정수]
 * 명령 [동쪽=1, 서쪽=2, 북쪽=3, 남쪽=4]
 *
 * 출력
 * 이동할 때마다 주사위의 윗 면에 쓰여있는 수를 출력.
 * 만약 바깥으로 이동시키려고 하는 경우에는 해당 명령을 무시 & 출력 x
 *
 * //==아이디어==//
 * 주사위 굴리기
 * 남북과 동서는 서로 돌리는 방향만 반대이지, 고려해야되는 면은 똑같다
 * 남북은 1열인 세로만 고려하면 되고 동서는 1행과 3행에 포함되는 칸들을 고려해야한다.
 * 즉, 남북은 (0, 1), (1, 1), (2, 1), (3, 1)을
 * 북쪽으로 이동하면, 아래쪽으로 shift, 남쪽으로 이동하면 위쪽으로 shift해주면 된다.
 *
 * 또, 동서는 (1, 0), (1, 1), (1, 2), (3, 1)을
 * 동쪽으로 이동하면 오른쪽으로 shift, 서쪽으로 이동하면 왼쪽으로 shift해주면 된다.
 *
 * 남북은 shift해주기 편한데, 동서가 문제다.
 * 배열을 분리해서 관리하면 윗면과 아랫면 정보가 일관성이 깨질 수 있다.
 * 아니면 shift시 고려해야하는 위치 정보를 미리 저장해 놓고 indicator로 가리키면서 이동시켜 가도 될듯?
 *
 * 구현은 분리해서 데이터를 저장해 놓는게 간단할 듯? 돌리고 윗면 아랫면만 일치하게 바꿔주면 되니까..
 * dice[2][4]로 선언하고 0행에는 앞,위,뒤,아래 정보를 1행에는 왼쪽,위,오른쪽,아래 정보를 저장하자.
 * 이렇게 하면 동쪽은 dice[1]을 오른쪽으로 shift하고 dice[0][1],dice[0][3]을 변경해주면 된다.
 * 서쪽은 dice[1]을 왼쪽으로 shift하고 dice[0][1],dice[0][3]을 변경해주면 된다.
 * 북쪽은 dice[0]을 오른쪽으로 shift하고 dice[1][1],dice[1][3]을 변경해주면 된다.
 * 남쪽은 dice[0]을 왼쪽으로 shift하고 dice[1][1],dice[1][3]을 변경해주면 된다.
 *
 * 이동한 칸이 0인지 0이 아닌지 판단해서 dice배열에다가 값을 옮기겨나 가져오게 만들면 끝난다.
 */