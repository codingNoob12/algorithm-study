#include <bits/stdc++.h>
using namespace std;

int n, m, r, c, d, ans;
int board[50][50];
bool vis[50][50];
// 북동남서
int dx[] = {-1, 0, 1, 0};
int dy[] = {0, 1, 0, -1};

void rotate() {
	d--;
	if (d < 0) d += 4;
}

void dfs(int x, int y) {
	//현재 칸이 청소 안된 상태 -> 청소
	if (!vis[x][y]) {
		vis[x][y] = 1;
		ans++;
	}

	//인접한 청소 안된 칸이 있는지 판단
	int cnt = 0;
	for (int dir = 0; dir < 4; dir++) {
		int nx = x + dx[dir], ny = y + dy[dir];
		if (nx < 0 || nx >= n || ny < 0 || ny >= m) continue;
		if (board[nx][ny] || vis[nx][ny]) continue;
		cnt++;
	}

	if (cnt) {
		rotate();
		int nx = x + dx[d], ny = y + dy[d];
		if (nx < 0 || nx >= n || ny < 0 || ny >= m || board[nx][ny] || vis[nx][ny]) dfs(x, y);
		else dfs(nx, ny);
	} else {
		// 후진 가능한지 판단
		int b = (d + 2) % 4;
		int nx = x + dx[b], ny = y + dy[b];
		if (board[nx][ny]) {
			cout << ans;
			exit(0);
		} else dfs(nx, ny);
	}
}

int main() {
	ios::sync_with_stdio(0);
	cin.tie(0);

	cin >> n >> m >> r >> c >> d;
	int cnt = 0;
	for (int i = 0; i < n; i++) {
		for (int j = 0; j < m; j++) {
			cin >> board[i][j];
		}
	}

	dfs(r, c);
}
/*
 * 문제
 * 방: n by m 크기의 직사각형; 빈칸과 벽으로 이루어짐
 * 청소기는 동, 서, 남, 북 중 한 곳을 바라보고 있다.
 *
 * 방의 각 칸은 좌표 (r, c)로 표현; 북서쪽 (0, 0), 남동쪽 (n-1, m-1)
 * 즉, (r, c)는 r행 c열임
 *
 * 빈 칸은 처음에는 전부 청소되지 않은 상태
 *
 * 로봇청소기의 작동 방식
 * 	1. 현재 칸이 청소 안된 상태 -> 청소
 * 	2. 인접한 4칸 중 청소 안된 빈칸 없음
 * 		1. 바라보는 방향을 유지한 채로 한 칸 후진 가능 -> 한 칸 후진하고 1번으로 되돌아감
 * 		2. 바라보는 방향의 뒤쪽 칸이 벽이라 후진 불가능 -> 작동 중지
 * 	3. 현재 칸의 주변 4칸 중 청소 안된 빈칸이 있음
 * 		1. 반시계 방향으로 90도 회전
 * 		2. 바라보는 방향을 기준으로 앞쪽 칸이 청소되지 않은 빈칸인 경우 한칸 전진
 * 		3. 1번으로 돌아간다.
 *
 * 입력
 * 방 크기 n과 m입력.
 * 청소기의 초기 좌표 r, c와 바라보는 방향 d가 주어짐; 북쪽=0, 동쪽=1, 남쪽=2, 서쪽=3
 * 방의 상태; 청소 안된 빈칸=0, 벽=1
 *
 * 출력
 * 청소되는 칸의 개수
 *
 * //==아이디어==//
 * 재귀로 구현해야 될 듯?
 *
 * 청소를 위해 다음 위치로 움직였다가 인접한 청소안된 칸이 존재하지 않으면, 되돌아와야 하기 때문이다.
 *
 * dfs로 구현하면, 돌아올 위치를 스택에 넣고 되돌아 왔다가 다시 다음 빈칸으로 이동하게 만드는 게
 * 구현이 귀찮아져서 그냥 재귀가 편함
 *
 * 청소 여부를 담는 vis배열 선언이 필요하다.
 * 청소기의 방향을 저장할 변수가 필요하다.
 * 방향 별로 이동할 수 있도록 dx, dy를 세팅해야 한다.
 *
 * 함수 내부에서 인접한 청소안된 칸이 존재하는지 파악.
 * 없으면, 후진 불가능하면 청소 안된 빈칸 개수 출력하고 exit(0)
 * 후진 가능하면 후진해서 다시 반복 (재방문 or 루프)
 *
 * 있으면, 앞에 청소 안된 칸이 있는지 파악.
 * 없으면, 반시계로 90도 회전; 청소기 방향 - 1해주고 음수면 +4 하는 방식으로 구현하면 될듯?
 * 그리고, 다시 방문 or 루프
 * 있으면, 앞으로 이동
 *
 * O(nm) = 2500
 */