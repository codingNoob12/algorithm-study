from collections import deque

N, M = map(int, input().split())
miro = [list(map(int, input())) for _ in range(N)]

start = (0, 0)
queue = deque([start])
dA = [(1, 0), (0, 1), (-1, 0), (0, -1)]

while queue:
    x, y = queue.popleft()
    for dx, dy in dA:
        next_x = x + dx
        next_y = y + dy

        if 0 <= next_x < N and 0 <= next_y < M and miro[next_x][next_y] == 1:
            queue.append((next_x, next_y))
            miro[next_x][next_y] = miro[x][y] + 1

print(miro[-1][-1])

# note)
# 이 문제의 미로는 N by M의 정사각형 모양이다.
# 이때, (1, 1)에서 (N, M)으로 이동하려면, 결과적으로 오른쪽 끝과 아래쪽 끝에 도달해야한다.
# 따라서, 어느 한 점에서는 무조건 오른쪽 혹은 아래로 이동이 가능하다.
# 하지만, (1, 1)에서 (N, M)으로 최단 경로로 이동하려면 가능한 한 항상 오른쪽 내지는 아래로만 이동해야한다.
#
# 미로의 값이 1인 지점에 한헤서 '이전 위치 값 + 1'으로 갱신한다면, 출발점을 제외한 나머지 지점들에서는 최단 경로로 이동한 거리로 갱신된다.
# 왜냐하면, 출발점을 제외한 나머지 지점들에서는 1인 인접한 지점은 항상 오른쪽 혹은 아래쪽에만 존재해야만 하기 때문이다.
# 즉, 기존 지점을 거쳐 현재 위치에 도달했을 것이므로 왼쪽 혹은 위쪽은 무조건 1이 아니기 때문이다.
# 덧붙혀, 출발점은 1로 시작하므로 출발점의 인접 지점에서 출발점으로 되돌아가게 되므로 출발점의 값은 1이 될 수가 없다.
#
# 위의 과정을 지나갈 수 있는 모든 지점들에 대해 반복히기 위해서는 BFS를 사용하는 것이 편리하다.
# 한 지점에서 방문가능한 모든 지점을 큐에 저장하고 다음 지점으로 이동하는 것이 모든 방문 가능한 지점의 값을 갱신하는데 효율적이기 때문이다.
